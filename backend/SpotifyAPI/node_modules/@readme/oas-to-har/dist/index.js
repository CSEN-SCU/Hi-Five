"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var data_urls_1 = require("@readme/data-urls");
var extensions = __importStar(require("@readme/oas-extensions"));
var oas_1 = require("oas");
var rmoas_types_1 = require("oas/dist/rmoas.types");
var remove_undefined_objects_1 = __importDefault(require("remove-undefined-objects"));
var configure_security_1 = __importDefault(require("./lib/configure-security"));
var style_formatting_1 = __importDefault(require("./lib/style-formatting"));
var jsonSchemaTypes = oas_1.utils.jsonSchemaTypes, matchesMimeType = oas_1.utils.matchesMimeType;
function formatter(values, param, type, onlyIfExists) {
    if (onlyIfExists === void 0) { onlyIfExists = false; }
    if (param.style) {
        var value_1 = values[type][param.name];
        // Note: Technically we could send everything through the format style and choose the proper
        // default for each `in` type (e.g. query defaults to form).
        return (0, style_formatting_1["default"])(value_1, param);
    }
    var value;
    // Handle missing values
    if (typeof values[type][param.name] !== 'undefined') {
        value = values[type][param.name];
    }
    else if (onlyIfExists && !param.required) {
        value = undefined;
    }
    else if (param.required && param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema["default"]) {
        value = param.schema["default"];
    }
    else if (type === 'path') {
        // If we don't have any values for the path parameter, just use the name of the parameter as the
        // value so we don't try try to build a URL to something like `https://example.com/undefined`.
        return param.name;
    }
    // Handle file uploads. Specifically arrays of file uploads which need to be formatted very
    // specifically.
    if (param.schema &&
        !(0, rmoas_types_1.isRef)(param.schema) &&
        param.schema.type === 'array' &&
        param.schema.items &&
        !(0, rmoas_types_1.isRef)(param.schema.items) &&
        param.schema.items.format === 'binary') {
        if (Array.isArray(value)) {
            // If this is array of binary data then we shouldn't do anything because we'll prepare them
            // separately in the HAR in order to preserve `fileName` and `contentType` data within
            // `postData.params`. If we don't then the HAR we generate for this data will be invalid.
            return value;
        }
        return JSON.stringify(value);
    }
    if (value !== undefined) {
        // Query params should always be formatted, even if they don't have a `style` serialization
        // configured.
        if (type === 'query') {
            return (0, style_formatting_1["default"])(value, param);
        }
        return value;
    }
    return undefined;
}
function multipartBodyToFormatterParams(multipartBody, oasMediaTypeObject) {
    var schema = oasMediaTypeObject.schema;
    var encoding = oasMediaTypeObject.encoding;
    if (typeof multipartBody === 'object' && multipartBody !== null) {
        return Object.keys(multipartBody)
            .map(function (key) {
            // If we have an incoming parameter, but it's not in the schema ignore it.
            if (!schema.properties[key]) {
                return false;
            }
            var paramEncoding = encoding ? encoding[key] : undefined;
            return {
                name: key,
                // If the style isn't defined, use the default
                style: paramEncoding ? paramEncoding.style : undefined,
                // If explode isn't defined, use the default
                explode: paramEncoding ? paramEncoding.explode : undefined,
                required: (schema.required && typeof schema.required === 'boolean' && Boolean(schema.required)) ||
                    (Array.isArray(schema.required) && schema.required.includes(key)),
                schema: schema.properties[key],
                "in": 'body'
            };
        })
            .filter(Boolean);
    }
    // Pretty sure that we'll never have anything but an object for multipart bodies, so returning
    // empty array if we get anything else.
    return [];
}
var defaultFormDataTypes = Object.keys(jsonSchemaTypes).reduce(function (prev, curr) {
    var _a;
    return Object.assign(prev, (_a = {}, _a[curr] = {}, _a));
}, {});
function getResponseContentType(content) {
    var types = Object.keys(content) || [];
    // If this response content has multiple types available we should always prefer the one that's
    // JSON-compatible. If they don't have one that is we'll return the first available, otherwise
    // if they don't have **any** repsonse content types present we'll assume it's JSON.
    if (types && types.length) {
        var jsonType = types.find(function (t) { return matchesMimeType.json(t); });
        if (jsonType) {
            return jsonType;
        }
        return types[0];
    }
    return 'application/json';
}
function isPrimitive(val) {
    return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';
}
function stringify(json) {
    return JSON.stringify((0, remove_undefined_objects_1["default"])(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));
}
function stringifyParameter(param) {
    if (param === null || isPrimitive(param)) {
        return param;
    }
    else if (Array.isArray(param) && param.every(isPrimitive)) {
        return String(param);
    }
    return JSON.stringify(param);
}
function appendHarValue(harParam, name, value, addtlData) {
    if (addtlData === void 0) { addtlData = {}; }
    if (typeof value === 'undefined')
        return;
    if (Array.isArray(value)) {
        // If the formatter gives us an array, we're expected to add each array value as a new
        // parameter item with the same parameter name
        value.forEach(function (singleValue) {
            appendHarValue(harParam, name, singleValue);
        });
    }
    else if (typeof value === 'object' && value !== null) {
        // If the formatter gives us an object, we're expected to add each property value as a new
        // parameter item, each with the name of the property
        Object.keys(value).forEach(function (key) {
            appendHarValue(harParam, key, value[key]);
        });
    }
    else {
        // If the formatter gives us a non-array, non-object, we add it as is
        harParam.push(__assign(__assign({}, addtlData), { name: name, value: String(value) }));
    }
}
function encodeBodyForHAR(body) {
    if (isPrimitive(body)) {
        return body;
    }
    else if (typeof body === 'object' &&
        body !== null &&
        !Array.isArray(body) &&
        typeof body.RAW_BODY !== 'undefined') {
        // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload as a
        // raw string. https://docs.readme.com/docs/raw-body-content
        if (isPrimitive(body.RAW_BODY)) {
            return body.RAW_BODY;
        }
        return stringify(body.RAW_BODY);
    }
    return stringify(body);
}
function oasToHar(oas, operationSchema, values, auth, opts) {
    var _a;
    if (values === void 0) { values = {}; }
    if (auth === void 0) { auth = {}; }
    if (opts === void 0) { opts = {
        // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in
        // order to funnel requests through our CORS-friendly proxy.
        proxyUrl: false
    }; }
    var operation;
    if (!operationSchema || typeof operationSchema.getParameters !== 'function') {
        /**
         * If `operationSchema` was supplied as a plain object instead of an instance of `Operation`
         * then we should create a new instance of it. We're doing it with a check on `getParameters`
         * instead of checking `instanceof Operation` because JS is very weird when it comes to
         * checking `instanceof` against classes. One instance of `Operation` may not always match up
         * with another if they're being loaded between two different libraries.
         *
         * It's weird. This is easier.
         */
        operation = new oas_1.Operation(oas, (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.path) || '', (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.method) || '', operationSchema || { path: '', method: '' });
    }
    else {
        operation = operationSchema;
    }
    var apiDefinition = oas.getDefinition();
    var formData = __assign(__assign(__assign({}, defaultFormDataTypes), { server: {
            selected: 0,
            variables: oas.defaultVariables(0)
        } }), values);
    // If the incoming `server.variables` is missing variables let's pad it out with defaults.
    formData.server.variables = __assign(__assign({}, oas.defaultVariables(formData.server.selected)), (formData.server.variables ? formData.server.variables : {}));
    var har = {
        cookies: [],
        headers: [],
        headersSize: 0,
        queryString: [],
        // @ts-expect-error This is fine because we're fleshing `postData` out further down.
        postData: {},
        bodySize: 0,
        method: operation.method.toUpperCase(),
        url: "".concat(oas.url(formData.server.selected, formData.server.variables)).concat(operation.path).replace(/\s/g, '%20'),
        httpVersion: 'HTTP/1.1'
    };
    if (opts.proxyUrl) {
        if (extensions.getExtension(extensions.PROXY_ENABLED, oas, operation)) {
            har.url = "https://try.readme.io/".concat(har.url);
        }
    }
    var parameters = operation.getParameters();
    har.url = har.url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, function (full, key) {
        if (!operation || !parameters)
            return key; // No path params at all
        // Find the path parameter or set a default value if it does not exist
        var parameter = parameters.find(function (param) { return param.name === key; }) || { name: key };
        // The library that handles our style processing already encodes uri elements. For everything
        // else we need to handle it here.
        if (!('style' in parameter) || !parameter.style) {
            return encodeURIComponent(formatter(formData, parameter, 'path'));
        }
        return formatter(formData, parameter, 'path');
    });
    var queryStrings = parameters && parameters.filter(function (param) { return param["in"] === 'query'; });
    if (queryStrings && queryStrings.length) {
        queryStrings.forEach(function (queryString) {
            var value = formatter(formData, queryString, 'query', true);
            appendHarValue(har.queryString, queryString.name, value);
        });
    }
    // Do we have any `cookie` parameters on the operation?
    var cookies = parameters && parameters.filter(function (param) { return param["in"] === 'cookie'; });
    if (cookies && cookies.length) {
        cookies.forEach(function (cookie) {
            var value = formatter(formData, cookie, 'cookie', true);
            appendHarValue(har.cookies, cookie.name, value);
        });
    }
    // Does this response have any documented content types?
    if (operation.schema.responses) {
        Object.keys(operation.schema.responses).some(function (response) {
            if ((0, rmoas_types_1.isRef)(operation.schema.responses[response]))
                return false;
            var content = operation.schema.responses[response].content;
            if (!content)
                return false;
            // If there's no `accept` header present we should add one so their eventual code snippet
            // follows best practices.
            if (Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'accept'; }))
                return true;
            har.headers.push({
                name: 'accept',
                value: getResponseContentType(content)
            });
            return true;
        });
    }
    // Do we have any `header` parameters on the operation?
    var hasContentType = false;
    var contentType = operation.getContentType();
    var headers = parameters && parameters.filter(function (param) { return param["in"] === 'header'; });
    if (headers && headers.length) {
        headers.forEach(function (header) {
            var value = formatter(formData, header, 'header', true);
            if (typeof value === 'undefined')
                return;
            if (header.name.toLowerCase() === 'content-type') {
                hasContentType = true;
                contentType = String(value);
            }
            appendHarValue(har.headers, header.name, value);
        });
    }
    // Are there `x-headers` static headers configured for this OAS?
    var userDefinedHeaders = extensions.getExtension(extensions.HEADERS, oas, operation);
    if (userDefinedHeaders) {
        userDefinedHeaders.forEach(function (header) {
            if (typeof header.key === 'string' && header.key.toLowerCase() === 'content-type') {
                hasContentType = true;
                contentType = String(header.value);
            }
            har.headers.push({
                name: String(header.key),
                value: String(header.value)
            });
        });
    }
    if (formData.header) {
        // Do we have an `accept` header set up in the form data, but it hasn't been added yet?
        var acceptHeader = Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'accept'; });
        if (acceptHeader && !har.headers.find(function (hdr) { return hdr.name.toLowerCase() === 'accept'; })) {
            har.headers.push({
                name: 'accept',
                value: String(formData.header[acceptHeader])
            });
        }
        // Do we have a manually-defined `authorization` header set up in the form data?
        var authorizationHeader = Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'authorization'; });
        if (authorizationHeader && !har.headers.find(function (hdr) { return hdr.name.toLowerCase() === 'authorization'; })) {
            har.headers.push({
                name: 'authorization',
                value: String(formData.header[authorizationHeader])
            });
        }
    }
    var requestBody;
    if (operation.hasRequestBody()) {
        // @ts-expect-error TODO `requestBody` coming back as `false | MediaTypeObject | [string, MediaTypeObject]` seems like a problem
        _a = __read(operation.getRequestBody(), 2), requestBody = _a[1];
    }
    if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {
        var requestBodySchema_1 = requestBody.schema;
        if (operation.isFormUrlEncoded()) {
            if (Object.keys(formData.formData).length) {
                var cleanFormData_1 = (0, remove_undefined_objects_1["default"])(JSON.parse(JSON.stringify(formData.formData)));
                if (cleanFormData_1 !== undefined) {
                    har.postData.params = [];
                    har.postData.mimeType = 'application/x-www-form-urlencoded';
                    Object.keys(cleanFormData_1).forEach(function (name) {
                        har.postData.params.push({
                            name: name,
                            value: stringifyParameter(cleanFormData_1[name])
                        });
                    });
                }
            }
        }
        else if ('body' in formData &&
            formData.body !== undefined &&
            (isPrimitive(formData.body) || Object.keys(formData.body).length)) {
            var isMultipart = operation.isMultipart();
            var isJSON = operation.isJson();
            if (isMultipart || isJSON) {
                try {
                    var cleanBody_1 = (0, remove_undefined_objects_1["default"])(JSON.parse(JSON.stringify(formData.body)));
                    if (isMultipart) {
                        har.postData.mimeType = 'multipart/form-data';
                        har.postData.params = [];
                        /**
                         * Discover all `{ type: string, format: binary }` properties, or arrays containing the
                         * same, within the request body. If there are any, then that means that we're dealing
                         * with a `multipart/form-data` request and need to treat the payload as
                         * `postData.params` and supply filenames and content types for the files (if they're
                         * available).
                         *
                         * @example `{ type: string, format: binary }`
                         * @example `{ type: array, items: { type: string, format: binary } }`
                         */
                        var binaryTypes_1 = Object.keys(requestBodySchema_1.properties).filter(function (key) {
                            var propData = requestBodySchema_1.properties[key];
                            if (propData.format === 'binary') {
                                return true;
                            }
                            else if (propData.type === 'array' &&
                                propData.items &&
                                typeof propData.items === 'object' &&
                                propData.items !== null &&
                                propData.items.format === 'binary') {
                                return true;
                            }
                            return false;
                        });
                        if (cleanBody_1 !== undefined) {
                            var multipartParams_1 = multipartBodyToFormatterParams(formData.body, operation.schema.requestBody.content['multipart/form-data']);
                            Object.keys(cleanBody_1).forEach(function (name) {
                                var param = multipartParams_1.find(function (multipartParam) { return multipartParam.name === name; });
                                // If we're dealing with a binary type, and the value is a valid data URL we should
                                // parse out any available filename and content type to send along with the
                                // parameter to interpreters like `fetch-har` can make sense of it and send a usable
                                // payload.
                                var addtlData = {};
                                var value = formatter(formData, param, 'body', true);
                                if (!Array.isArray(value)) {
                                    value = [value];
                                }
                                value.forEach(function (val) {
                                    if (binaryTypes_1.includes(name)) {
                                        var parsed = (0, data_urls_1.parse)(val);
                                        if (parsed) {
                                            addtlData.fileName = 'name' in parsed ? parsed.name : 'unknown';
                                            if ('contentType' in parsed) {
                                                addtlData.contentType = parsed.contentType;
                                            }
                                        }
                                    }
                                    appendHarValue(har.postData.params, name, val, addtlData);
                                });
                            });
                        }
                    }
                    else {
                        har.postData.mimeType = contentType;
                        /**
                         * Handle arbitrary JSON input via a string.
                         *
                         * In OAS you usually find this in an `application/json` content type with a schema
                         * `type=string, format=json`. In the UI this is represented by an arbitrary text input.
                         *
                         * This ensures we remove any newlines or tabs and use a clean JSON block in the
                         * example.
                         */
                        if (requestBody.schema.type === 'string') {
                            har.postData.text = JSON.stringify(JSON.parse(cleanBody_1));
                        }
                        else {
                            /**
                             * Handle formatted JSON objects that have properties that accept arbitrary JSON.
                             *
                             * Find all `{ type: string, format: json }` properties in the schema because we need
                             * to manually `JSON.parse` them before submit, otherwise they'll be escaped instead
                             * of actual objects. We also only want values that the user has entered, so we drop
                             * any `undefined` `cleanBody` keys.
                             */
                            var jsonTypes = Object.keys(requestBodySchema_1.properties).filter(function (key) {
                                var propData = requestBodySchema_1.properties[key];
                                return propData.format === 'json' && cleanBody_1[key] !== undefined;
                            });
                            if (jsonTypes.length) {
                                try {
                                    jsonTypes.forEach(function (prop) {
                                        try {
                                            cleanBody_1[prop] = JSON.parse(cleanBody_1[prop]);
                                        }
                                        catch (e) {
                                            // leave the prop as a string value
                                        }
                                    });
                                    // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload
                                    // as a raw string. https://docs.readme.com/docs/raw-body-content
                                    if (typeof cleanBody_1.RAW_BODY !== 'undefined') {
                                        cleanBody_1 = cleanBody_1.RAW_BODY;
                                    }
                                    har.postData.text = JSON.stringify(cleanBody_1);
                                }
                                catch (e) {
                                    har.postData.text = stringify(formData.body);
                                }
                            }
                            else {
                                har.postData.text = encodeBodyForHAR(formData.body);
                            }
                        }
                    }
                }
                catch (e) {
                    // If anything above fails for whatever reason, assume that whatever we had is invalid
                    // JSON and just treat it as raw text.
                    har.postData.text = stringify(formData.body);
                }
            }
            else {
                har.postData.mimeType = contentType;
                har.postData.text = encodeBodyForHAR(formData.body);
            }
        }
    }
    // Add a `content-type` header if there are any body values setup above or if there is a schema
    // defined, but only do so if we don't already have a `content-type` present as it's impossible
    // for a request to have multiple.
    if ((har.postData.text || (requestBody && requestBody.schema && Object.keys(requestBody.schema).length)) &&
        !hasContentType) {
        har.headers.push({
            name: 'content-type',
            value: contentType
        });
    }
    var securityRequirements = operation.getSecurity();
    if (securityRequirements && securityRequirements.length) {
        // TODO pass these values through the formatter?
        securityRequirements.forEach(function (schemes) {
            Object.keys(schemes).forEach(function (security) {
                var securityValue = (0, configure_security_1["default"])(apiDefinition, auth, security);
                if (!securityValue) {
                    return;
                }
                // If this is an `authorization` header and we've already added one (maybe one was manually
                // specified), then we shouldn't add another.
                if (securityValue.value.name === 'authorization') {
                    if (har[securityValue.type].find(function (v) { return v.name === securityValue.value.name; })) {
                        return;
                    }
                }
                // If we've already added this **specific** security value then don't add it again.
                if (har[securityValue.type].find(function (v) { return v.name === securityValue.value.name && v.value === securityValue.value.value; })) {
                    return;
                }
                har[securityValue.type].push(securityValue.value);
            });
        });
    }
    // If we didn't end up filling the `postData` object then we don't need it.
    if (Object.keys(har.postData).length === 0) {
        delete har.postData;
    }
    return {
        log: {
            entries: [
                {
                    request: har
                },
            ]
        }
    };
}
exports["default"] = oasToHar;
