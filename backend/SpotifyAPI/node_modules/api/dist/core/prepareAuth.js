"use strict";
exports.__esModule = true;
function prepareAuth(authKey, operation) {
    if (authKey.length === 0) {
        return {};
    }
    var preparedAuth = {};
    var security = operation.getSecurity();
    if (security.length === 0) {
        // If there's no auth configured on this operation, don't prepare anything (even if it was
        // supplied by the user).
        return {};
    }
    // Does this operation require multiple forms of auth?
    if (security.every(function (s) { return Object.keys(s).length > 1; })) {
        throw new Error("Sorry, this operation currently requires multiple forms of authentication which this library doesn't yet support.");
    }
    // Since we can only handle single auth security configurations, let's pull those out. This code
    // is a bit opaque but `security` here may look like `[{ basic: [] }, { oauth2: [], basic: []}]`
    // and are filtering it down to only single-auth requirements of `[{ basic: [] }]`.
    var usableSecurity = security
        .map(function (s) {
        return Object.keys(s).length === 1 ? s : false;
    })
        .filter(Boolean);
    var usableSecuritySchemes = usableSecurity.map(function (s) { return Object.keys(s); }).reduce(function (prev, next) { return prev.concat(next); }, []);
    var preparedSecurity = operation.prepareSecurity();
    // If we have two auth tokens present let's look for Basic Auth in their configuration.
    if (authKey.length >= 2) {
        // If this operation doesn't support HTTP Basic auth but we have two tokens, that's a paddlin.
        if (!('Basic' in preparedSecurity)) {
            throw new Error('Multiple auth tokens were supplied for this endpoint but only a single token is needed.');
        }
        // If we have two auth keys for Basic Auth but Basic isn't a usable security scheme (maybe it's
        // part of an AND or auth configuration -- which we don't support) then we need to error out.
        var schemes_1 = preparedSecurity.Basic.filter(function (s) { return usableSecuritySchemes.includes(s._key); });
        if (!schemes_1.length) {
            throw new Error('Credentials for Basic Authentication were supplied but this operation requires another form of auth in that case, which this library does not yet support. This operation does, however, allow supplying a single auth token.');
        }
        var scheme_1 = schemes_1.shift();
        preparedAuth[scheme_1._key] = {
            user: authKey[0],
            pass: authKey.length === 2 ? authKey[1] : ''
        };
        return preparedAuth;
    }
    // If we know we don't need to use HTTP Basic auth because we have a username+password then we
    // can pick the first usable security scheme available and try to use that. This might not always
    // be the auth scheme that the user wants, but we don't have any other way for the user to tell
    // us what they want with the current `sdk.auth()` API.
    var usableScheme = usableSecuritySchemes[0];
    var schemes = Object.entries(preparedSecurity)
        .map(function (_a) {
        var ps = _a[1];
        return ps.filter(function (s) { return usableScheme === s._key; });
    })
        .reduce(function (prev, next) { return prev.concat(next); }, []);
    var scheme = schemes.shift();
    switch (scheme.type) {
        case 'http':
            if (scheme.scheme === 'basic') {
                preparedAuth[scheme._key] = {
                    user: authKey[0],
                    pass: authKey.length === 2 ? authKey[1] : ''
                };
            }
            else if (scheme.scheme === 'bearer') {
                preparedAuth[scheme._key] = authKey[0];
            }
            break;
        case 'oauth2':
            preparedAuth[scheme._key] = authKey[0];
            break;
        case 'apiKey':
            if (scheme["in"] === 'query' || scheme["in"] === 'header' || scheme["in"] === 'cookie') {
                preparedAuth[scheme._key] = authKey[0];
            }
            break;
        default:
            throw new Error("Sorry, this API currently uses a security scheme, ".concat(scheme.type, ", which this library doesn't yet support."));
    }
    return preparedAuth;
}
exports["default"] = prepareAuth;
