import type Storage from '../../storage';
import type { InstallerOptions } from '../language';
import type Oas from 'oas';
import type { Operation } from 'oas';
import type { ClassDeclaration, JSDocStructure, JSDocTagStructure, OptionalKind } from 'ts-morph';
import { Project } from 'ts-morph';
import CodeGeneratorLanguage from '../language';
export interface TSGeneratorOptions {
    compilerTarget?: 'cjs' | 'esm';
    outputJS?: boolean;
}
interface OperationTypeHousing {
    operation: Operation;
    types: {
        params?: false | Record<'body' | 'formData' | 'metadata', string>;
        responses?: Record<string | number, {
            description?: string;
            type: string;
        }>;
    };
}
export default class TSGenerator extends CodeGeneratorLanguage {
    project: Project;
    outputJS: boolean;
    compilerTarget: 'cjs' | 'esm';
    types: Map<string, string>;
    files: Record<string, string>;
    sdk: ClassDeclaration;
    schemas: Record<string, {
        body?: any;
        metadata?: any;
        response?: Record<string, any>;
    } | Record<string, any>>;
    usesHTTPMethodRangeInterface: boolean;
    constructor(spec: Oas, specPath: string, identifier: string, opts?: TSGeneratorOptions);
    installer(storage: Storage, opts?: InstallerOptions): Promise<void>;
    /**
     * Compile the current OpenAPI definition into a TypeScript library.
     *
     */
    generator(): Promise<{
        [x: string]: string;
    }>;
    /**
     * Create our main SDK source file.
     *
     */
    createSourceFile(): import("ts-morph").SourceFile;
    /**
     * Create our main schemas file. This is where all of the JSON Schema that our TypeScript typing
     * infrastructure sources its data from. Without this there are no types.
     *
     */
    createSchemasFile(): import("ts-morph").SourceFile;
    /**
     * Create our main types file. This sources its data from the JSON Schema `schemas.ts` file and
     * will re-export types to be used in TypeScript implementations and IDE intellisense. This
     * typing work is functional with the `json-schema-to-ts` library.
     *
     * @see {@link https://npm.im/json-schema-to-ts}
     */
    createTypesFile(): import("ts-morph").SourceFile;
    /**
     * Add a new JSDoc `@tag` to an existing docblock.
     *
     */
    static addTagToDocblock(docblock: OptionalKind<JSDocStructure>, tag: OptionalKind<JSDocTagStructure>): {
        tags: OptionalKind<JSDocTagStructure>[];
        description?: string | import("ts-morph").WriterFunction;
        leadingTrivia?: string | import("ts-morph").WriterFunction | (string | import("ts-morph").WriterFunction)[];
        trailingTrivia?: string | import("ts-morph").WriterFunction | (string | import("ts-morph").WriterFunction)[];
        kind?: import("ts-morph").StructureKind.JSDoc;
    };
    /**
     * Create operation accessors on the SDK.
     *
     */
    createOperationAccessor(operation: Operation, operationId: string, paramTypes?: OperationTypeHousing['types']['params'], responseTypes?: OperationTypeHousing['types']['responses']): void;
    /**
     * Scour through the current OpenAPI definition and compile a store of every operation, along
     * with every HTTP method that's in use, and their available TypeScript types that we can use,
     * along with every HTTP method that's in use.
     *
     */
    loadOperationsAndMethods(): {
        operations: Record<string, OperationTypeHousing>;
        methods: Set<unknown>;
    };
    /**
     * Compile the parameter (path, query, cookie, and header) schemas for an API operation into
     * usable TypeScript types.
     *
     */
    prepareParameterTypesForOperation(operation: Operation, operationId: string): false | Record<"formData" | "body" | "metadata", string>;
    /**
     * Compile the response schemas for an API operation into usable TypeScript types.
     *
     */
    prepareResponseTypesForOperation(operation: Operation, operationId: string): {
        [x: string]: {
            type: string;
            description: any;
        };
    };
    /**
     * Add a given schema into our schema dataset that we'll be be exporting as types.
     *
     */
    addSchemaToExport(schema: any, typeName: string, pointer: string): void;
}
export {};
