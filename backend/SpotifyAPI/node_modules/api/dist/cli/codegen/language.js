"use strict";
exports.__esModule = true;
var packageInfo_1 = require("../../packageInfo");
var CodeGeneratorLanguage = /** @class */ (function () {
    function CodeGeneratorLanguage(spec, specPath, identifier) {
        this.spec = spec;
        this.specPath = specPath;
        // User agents should be contextual to the spec in question and the version of `api` that was
        // used to generate the SDK. For example, this'll look like `petstore/1.0.0 (api/4.2.0)` for
        // a `petstore` spec installed on api@4.2.0.
        var info = spec.getDefinition().info;
        this.userAgent = "".concat(identifier, "/").concat(info.version, " (").concat(packageInfo_1.PACKAGE_NAME, "/").concat(packageInfo_1.PACKAGE_VERSION, ")");
        /**
         * This check is barbaric but there are a number of issues with how the `transformer` work we
         * have in `oas` and in `.getParametersAsJSONSchema()` and `.getResponseAsJSONSchema()` that
         * are fully crashing when attempting to codegen an SDK for an API definition that has a
         * circular reference.
         *
         * In order to get v5 out the door we're not going to support this case initialy.
         *
         * @see {@link https://github.com/readmeio/api/issues/549}
         */
        if (JSON.stringify(spec.api).includes('"$ref":"#/')) {
            throw new Error('Sorry, this library does not yet support generating an SDK for an OpenAPI definition that contains circular references.');
        }
    }
    CodeGeneratorLanguage.prototype.hasRequiredPackages = function () {
        return Boolean(Object.keys(this.requiredPackages));
    };
    return CodeGeneratorLanguage;
}());
exports["default"] = CodeGeneratorLanguage;
